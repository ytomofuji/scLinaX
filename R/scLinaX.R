#' @importFrom dplyr filter select group_by summarize ungroup mutate left_join
#' @importFrom dplyr arrange distinct slice pull rename inner_join bind_rows n n_distinct case_when
#' @importFrom purrr map
#' @importFrom igraph graph clusters
#' @importFrom tibble tibble
#' @importFrom stringr str_c
#' @importFrom stats cor.test
#' @importFrom magrittr %>%
#' @importFrom readr write_tsv
#' @importFrom utils  globalVariables
NULL

utils::globalVariables(c("ALT", "ALT1", "ALT2", "ALTcount", "ALTratio", "A_allele", "A_allele_count",
"B_allele", "B_allele_count", "CHR", "Count", "Gene", "Gene_class",
"Major_allele", "Major_allele_count", "Mean_AR", "Mean_AR_reference",
"Mean_AR_target", "Minor_allele_count", "N_TotalCell", "OTHcount", "P",
"POS", "Peak_name", "REF", "REF1", "REF2", "REFcount", "Reference_Cell_Count",
"Reference_Gene", "Reference_SNP", "SNP", "SNP1", "SNP2", "SNP_ID", "Sample_ID",
"Sample_N", "TOTALcount", "Total_A_allele", "Total_B_allele", "Total_allele",
"Total_allele_count", "Used_as_refGene", "Used_as_refSNP", "XCI_annotation",
"XCI_ref", "XCI_status", "Xa", "case_when", "cell_barcode", "data", "flip_or_not",
"median", "minor_allele_ratio", "n", "dplyr::n_distinct", "rho", "tag"))


#' QC to remove potential escapee genes from reference gene set
#' @param QCREF Dataframe generated for QC of the reference genes (please also see the `run_RefGeneQC` function). QCREF should have the following three columns:
#' * Gene
#' * Mean_AR_target
#' * Mean_AR_reference
#' @param THR Threshold for the ratio of the expression from Xi.
#' The default is 0.05, but it should be adjusted according to your dataset.

Gene_QC <- function(QCREF, THR = 0.05) {
  tmp <- dplyr::filter(QCREF, Mean_AR_target < THR & Mean_AR_reference < THR)
  res <- tmp$Gene
  return(res)
}





#' Quality Control of the input data frame (for internal use only)
#' @param DATA Input scASE data frame
#' @param XCI_ref XCI status reference data
#' @param SNP_DETECTION_DP Threshold for read depth
#' @param SNP_DETECTION_MAF Threshold for minor allele frequency

make_QCed_df<-function(DATA,XCI_ref,SNP_DETECTION_DP=30,SNP_DETECTION_MAF=0.1){
  #make depth vs ALT allele ratio df
  per_sample_SNP<-DATA%>%
    dplyr::group_by(SNP_ID,Sample_ID)%>%
    dplyr::summarize(REFcount=sum(REFcount),ALTcount=sum(ALTcount))%>%
    dplyr::ungroup()%>%
    dplyr::mutate(TOTALcount=REFcount+ALTcount)%>%
    dplyr::mutate(ALTratio=ALTcount/TOTALcount)

  write_tsv(per_sample_SNP,"Initial_total_allele_count_vs_ALT_allele_ratio.tsv.gz")

  #QC based on MAF and DP
  QCpassed_var_cell<-dplyr::filter(per_sample_SNP,TOTALcount>=SNP_DETECTION_DP)%>%
    dplyr::filter(ALTratio>SNP_DETECTION_MAF & ALTratio<(1-SNP_DETECTION_MAF))%>%
    dplyr::select(SNP_ID,Sample_ID)

  #annotate XCI status
  QCed_df<-dplyr::left_join(QCpassed_var_cell,DATA,by=c("SNP_ID","Sample_ID"))%>%dplyr::left_join(XCI_ref,by="Gene")
  QCed_df$XCI_status[is.na(QCed_df$XCI_status)]<-"Unknown"

  QCed_df<-QCed_df%>%dplyr::mutate(CHR=dplyr::case_when(POS<=2781479~"PAR1",POS>=155701383~"PAR2",TRUE~"nonPAR"))%>%
    dplyr::mutate(Gene_class=dplyr::case_when(
      CHR=="PAR1"~"PAR1",CHR=="PAR2"~"PAR2",
      XCI_status=="escape"~"nonPAR_escape",
      XCI_status=="variable"~"nonPAR_variable",
      XCI_status=="inactive"~"nonPAR_inactive",
      XCI_status=="Unknown"~"nonPAR_unknown"))

  QCed_df$Gene_class<-factor(QCed_df$Gene_class,levels=c("PAR1","nonPAR_escape","nonPAR_variable","nonPAR_inactive","nonPAR_unknown","PAR2"))

  return(QCed_df)
}





#' Generate a per-SNP summary of the number of samples (for internal use only)
#' @param QCed_df Processed scASE data frame generated by the make_QCed_df function

make_per_SNP_sample_df<-function(QCed_df){

  per_SNP_sample<-QCed_df%>%
    dplyr::group_by(Gene,Gene_class,Sample_ID,SNP_ID)%>%
    dplyr::summarize(Count=dplyr::n())%>%
    dplyr::arrange(-Count)%>%
    dplyr::ungroup()

  return(per_SNP_sample)
}





#' Create pseudobulk data for reference SNPs (for internal use only)
#' @param DF Individual-level scASE data frame
#' @param REFSNP ID of the reference SNP

make_pseudobulk_refSNP<-function(DF,REFSNP){
  #cells expressing ref allele of the reference snp
  refcell<-dplyr::filter(DF,SNP_ID==REFSNP & REFcount>0 & ALTcount==0 & OTHcount==0)%>%dplyr::pull(cell_barcode)%>%unique()
  #cells expressing alt allele of the reference snp
  altcell<-dplyr::filter(DF,SNP_ID==REFSNP & REFcount==0 & ALTcount>0 & OTHcount==0)%>%dplyr::pull(cell_barcode)%>%unique()
  #make pseudobulk for each group
  ref_pseudobulk<-dplyr::filter(DF,cell_barcode %in% refcell)%>%
    dplyr::group_by(SNP_ID,CHR,POS,REF,ALT,Gene_class)%>%
    dplyr::summarize(REFcount=sum(REFcount),ALTcount=sum(ALTcount))%>%
    dplyr::ungroup()

  #Flip REF and ALT because cells in ref_pseudobulk and alt_presudobulk have different Xi
  alt_pseudobulk<-dplyr::filter(DF,cell_barcode %in% altcell)%>%
    dplyr::group_by(SNP_ID,CHR,POS,REF,ALT,Gene_class)%>%
    dplyr::summarize(REFcount=sum(ALTcount),ALTcount=sum(REFcount))%>%
    dplyr::ungroup()

  #merge ref/alt _pseudobulk
  pseudobulk<-dplyr::bind_rows(ref_pseudobulk,alt_pseudobulk)%>%
    dplyr::group_by(SNP_ID,CHR,POS,REF,ALT,Gene_class)%>%
    dplyr::summarize(REFcount=sum(REFcount),ALTcount=sum(ALTcount))%>%
    dplyr::ungroup()%>%
    dplyr::mutate(tag=REFSNP,N_RefCell=length(refcell),N_AltCell=length(altcell),N_TotalCell=length(refcell)+length(altcell))

  #return tibble object
  return(pseudobulk)
}



#' Generate pseudobulk profiles for individuals and calculate correlations (for internal use only)
#' @inheritParams run_scLinaX
#' @param per_SNP_sample Output from `make_per_SNP_sample_df` function
#' @param QCed_df `Output from make_QCed_df` function
#' @param Sample Sample ID
#' @param valid_ref_genes Output from `Gene_QC` function
#'
run_clustering<-function(per_SNP_sample,QCed_df,Sample,valid_ref_genes,HE_allele_cell_number_THR=50,QC_total_allele_THR=10,REMOVE_ESCAPE=TRUE,PVAL_THR=0.01,RHO_THR=0.5){
  tmp_df<-dplyr::filter(QCed_df,Sample_ID==Sample)

#Extract candidate reference SNPs
cand_ref_snps_table<-dplyr::filter(per_SNP_sample,Sample_ID==Sample&Count>=HE_allele_cell_number_THR)%>%
  dplyr::filter(Gene %in% valid_ref_genes)%>%
  dplyr::select(SNP_ID,Gene)%>%dplyr::distinct()
cand_ref_snps<-cand_ref_snps_table$SNP_ID

#make pseudobulk ASE profiles for each reference SNPs
raw_expdf_for_clst<-purrr::map(cand_ref_snps,function(x){make_pseudobulk_refSNP(tmp_df,x)})%>%
  dplyr::bind_rows()%>%dplyr::left_join(cand_ref_snps_table,by=c("tag"="SNP_ID"))

#remove genes on the PAR and known escapees
expdf_for_clst<-raw_expdf_for_clst%>%dplyr::filter(Gene_class!="PAR1" & Gene_class!="PAR2")
if(REMOVE_ESCAPE==TRUE){expdf_for_clst<-expdf_for_clst%>%dplyr::filter(Gene_class!="nonPAR_escape")}

ref_snp_qc<-expdf_for_clst%>%
  dplyr::filter(REFcount+ALTcount>=QC_total_allele_THR)%>%
  dplyr::mutate(minor_allele_ratio=ifelse(REFcount>ALTcount,ALTcount/(REFcount+ALTcount),REFcount/(REFcount+ALTcount)))%>%
  dplyr::group_by(tag)%>%
  dplyr::summarize(Median_Minor_allele_ratio=median(minor_allele_ratio),Mean_Minor_allele_ratio=mean(minor_allele_ratio),NUM_SNP=dplyr::n())

#Calculate correlation of minor allele ratio for all of the reference SNPs
if(length(cand_ref_snps)>1){
  clst_res<-tibble()
  for(i in 1:(length(cand_ref_snps)-1)){
    for(j in (i+1):length(cand_ref_snps)){
      snp1<-cand_ref_snps[i]
      snp2<-cand_ref_snps[j]
      cell_num_snp1<-dplyr::filter(expdf_for_clst,tag==snp1)%>%dplyr::slice(1)%>%dplyr::pull(N_TotalCell)
      cell_num_snp2<-dplyr::filter(expdf_for_clst,tag==snp2)%>%dplyr::slice(1)%>%dplyr::pull(N_TotalCell)
      #extract snps with allelic-biased expression
      df_snp1<-dplyr::filter(expdf_for_clst,tag==snp1)%>%dplyr::filter(REFcount+ALTcount>0)%>%
        dplyr::select(SNP_ID,Gene_class,REFcount,ALTcount)%>%
        dplyr::rename(REF1=REFcount,ALT1=ALTcount)

      df_snp2<-dplyr::filter(expdf_for_clst,tag==snp2)%>%dplyr::filter(REFcount+ALTcount>0)%>%
        dplyr::select(SNP_ID,REFcount,ALTcount)%>%
        dplyr::rename(REF2=REFcount,ALT2=ALTcount)

      df_snp<-dplyr::inner_join(df_snp1,df_snp2,by="SNP_ID")%>%
        dplyr::mutate(ALTRatio1=ALT1/(REF1+ALT1),ALTRatio2=ALT2/(REF2+ALT2))

      ratio_cor<-try({stats::cor.test(df_snp$ALTRatio1,df_snp$ALTRatio2,method="spearman",exact=FALSE)})
      if ("try-error" %in% class(ratio_cor)) {ratio_cor <- list(estimate=0,p.value=1)}

      clst_res<-dplyr::bind_rows(clst_res,
                          tibble(SNP1=snp1,SNP2=snp2,rho=ratio_cor$estimate,P=ratio_cor$p.value,
                                 N_SNP=nrow(df_snp),N_Cell_SNP1=cell_num_snp1,N_Cell_SNP2=cell_num_snp2))

      df_snp<-dplyr::mutate(df_snp,SNP1=snp1,SNP2=snp2,Sample_ID=Sample,N_SNP=nrow(df_snp),N_Cell_SNP1=cell_num_snp1,N_Cell_SNP2=cell_num_snp2)
    }
  }
  Merge_list<-dplyr::filter(clst_res,P<PVAL_THR & (rho>RHO_THR | rho<(-1*RHO_THR)))%>%
    dplyr::mutate(flip_or_not=ifelse(rho>0,1,-1))
  phasing_result<-dplyr::mutate(clst_res,Sample_ID=Sample)


#Run phasing if there were any pairs of SNPs which were phased with high accuracy
if(nrow(Merge_list)>0){ #### if node to dealt with the case where there were no pairs of SNPs which were phased with high accuracy ####
  #Make network to merge the group of the phased SNPs
  edges<-c()
  for(i in 1:nrow(Merge_list)){
    edges<-c(edges,Merge_list$SNP1[i],Merge_list$SNP2[i])
  }
  non_clst<-c(cand_ref_snps[!(cand_ref_snps%in%edges)]) #also add SNPs which were not included in the Merge_list
  g1 <- igraph::graph(edges=edges,isolates=non_clst,directed=F)
  CLST1<-igraph::clusters(g1)$membership

  ###Save results of 1. phasing and 2. clustering###

}else{
  #### if node to dealt with the case where there were no pairs of SNPs which were phased with high accuracy ####
  Merge_list<-tibble::tibble(SNP1=NA,SNP2=NA,NUM_SNP1=NA,NUM_SNP2=NA,NUM_REF_REF=NA,NUM_REF_ALT=NA,NUM_ALL_intersect=NA,flip_or_not=NA)
  CLST1<-c(seq(1,length(cand_ref_snps)))
  names(CLST1)<-cand_ref_snps

  #### if node to dealt with the case where there were no pairs of SNPs which were phased with high accuracy ####
}}else{
  # Case where there was only a single SNP [if(length(cand_ref_snps)>1)]
  Merge_list<-tibble::tibble(SNP1=NA,SNP2=NA,NUM_SNP1=NA,NUM_SNP2=NA,NUM_REF_REF=NA,NUM_REF_ALT=NA,NUM_ALL_intersect=NA,flip_or_not=NA)
  CLST1<-c(1)
  names(CLST1)<-cand_ref_snps
}

#make a list of outputs
result_list=list(raw_expdf_for_clst=raw_expdf_for_clst,df_snp=df_snp,Merge_list=Merge_list,CLST1=CLST1,phasing_result=phasing_result,
                 clustering_result=tibble::tibble(SNP=names(CLST1),Cluster=stringr::str_c(Sample,CLST1,sep="_cluster_")))

return(result_list)

}





#' Define groups for SNP alleles (for internal use only)
#' @param CLST1 Output from the clustering function
#' @param Merge_list Output from the clustering function
#' @param QCed_df `Output from make_QCed_df` function
#' @param Sample Sample ID

run_grouping<-function(CLST1,Merge_list,QCed_df,Sample){

 expdf_withref_summary<-tibble::tibble()
 Max_Num_Table_summary<-tibble::tibble()
 per_sample_res_summary<-tibble::tibble()
 Fail_samples=c()
# flip alleles and merge allelic expression data across the cells in cluster
for(CLST_ID in unique(CLST1)){
  # list and phasing result of the variants in the cluster specified by 'CLST_ID' (Ordered according to the number of the detected cells)
  merged_vars<-names(CLST1[CLST1==CLST_ID])
  merged_vars_df<-dplyr::filter(Merge_list,SNP1%in%merged_vars & SNP2%in%merged_vars)

  # Initialize
  result_SNP_list<-tibble::tibble(SNP=merged_vars[1],flip_or_not=1) #SNPs and their phase
  evaluated_SNPs<-c(merged_vars[1]) #List of the already evaluated SNPs
  FAIL<-FALSE #if an inconsistency in phasing happens, FAIL bacome TRUE and result for the cluster would be dumped

  # Determine the phase of SNPs for all of the SNPs in the merged vars
  for(i in c(1:length(merged_vars))){
    target_SNP<-evaluated_SNPs[i]
    target_SNP_direction<-dplyr::filter(result_SNP_list,SNP==target_SNP)%>%
      dplyr::pull(flip_or_not)

    # extract associated edges (SNP in dicated in the SNP1 columns is matched to the target SNP)
    SNP1_target_df<-dplyr::filter(merged_vars_df,SNP1==target_SNP)
    if(nrow(SNP1_target_df)>0){
      for(j in 1:nrow(SNP1_target_df)){
        new_SNP<-SNP1_target_df$SNP2[j]
        if(!(new_SNP %in% evaluated_SNPs)){
          # new SNP was still not evaluated for flip or not -> evaluate and add to the result
          evaluated_SNPs<-c(evaluated_SNPs,new_SNP)
          new_SNP_direction<-SNP1_target_df$flip_or_not[j]*target_SNP_direction
          result_SNP_list<-dplyr::bind_rows(result_SNP_list,tibble::tibble(SNP=new_SNP,flip_or_not=new_SNP_direction))
        }else{
          # new SNP was already evaluated for flip or not -> consistency check
          new_SNP_direction<-dplyr::filter(result_SNP_list,SNP==new_SNP)%>%dplyr::pull(flip_or_not)
          if((SNP1_target_df$flip_or_not[j]*target_SNP_direction)!=new_SNP_direction){
            FAIL<-TRUE
          }}}}

    # extract associated edges (SNP in dicated in the SNP2 columns is matched to the target SNP)
    SNP2_target_df<-dplyr::filter(merged_vars_df,SNP2==target_SNP)
    if(nrow(SNP2_target_df)>0){
      for(j in 1:nrow(SNP2_target_df)){
        new_SNP<-SNP2_target_df$SNP1[j]
        if(!(new_SNP %in% evaluated_SNPs)){
          # new SNP was still not evaluated for flip or not -> evaluate and add to the result
          evaluated_SNPs<-c(evaluated_SNPs,new_SNP)
          new_SNP_direction<-SNP2_target_df$flip_or_not[j]*target_SNP_direction
          result_SNP_list<-dplyr::bind_rows(result_SNP_list,tibble(SNP=new_SNP,flip_or_not=new_SNP_direction))
        }else{
          # new SNP was already evaluated for flip or not -> consistency check
          new_SNP_direction<-dplyr::filter(result_SNP_list,SNP==new_SNP)%>%dplyr::pull(flip_or_not)
          if((SNP2_target_df$flip_or_not[j]*target_SNP_direction)!=new_SNP_direction){
            FAIL<-TRUE
          }}}}
    # Finish evaluation for the target SNP -> next target SNP
  }

  # if FAIL is false, phasing of the variants had finished without inconsistency -> save the results
  # define cell groups (whether allele A/B expressed). Bi-allelic expression cells were removed as candidate doublets
  if(FAIL==TRUE){
    Fail<-stringr::str_c(Sample,CLST_ID,sep="_")
    Fail_samples=c(Fail_samples,Fail)
  }else{
    source_df<-dplyr::filter(QCed_df,Sample_ID==Sample)
    reference_genes<-dplyr::filter(source_df,SNP_ID%in%merged_vars)%>%dplyr::pull(Gene)%>%unique()
    cell_define<-dplyr::inner_join(source_df,result_SNP_list,by=c("SNP_ID"="SNP"))%>%
      dplyr::mutate(A_allele_count=ifelse(flip_or_not==1,REFcount,ALTcount),
             B_allele_count=ifelse(flip_or_not==1,ALTcount,REFcount))%>%
      dplyr::group_by(cell_barcode)%>%
      dplyr::summarize(A_allele_count=sum(A_allele_count),B_allele_count=sum(B_allele_count),OTHcount=sum(OTHcount))%>%
      dplyr::ungroup()%>%
      dplyr::mutate(XCI_annotation=dplyr::case_when(
        A_allele_count>0&B_allele_count==0&OTHcount==0~"A_allele",
        A_allele_count==0&B_allele_count>0&OTHcount==0~"B_allele",
        TRUE~"Fail"
      ))

    # make new data frame based on the phasing result (per cell/sample allele count data)
    A_allele_cells<-dplyr::filter(cell_define,XCI_annotation=="A_allele")%>%dplyr::pull(cell_barcode)
    B_allele_cells<-dplyr::filter(cell_define,XCI_annotation=="B_allele")%>%dplyr::pull(cell_barcode)
    Fail_cells<-dplyr::filter(cell_define,XCI_annotation=="Fail")%>%dplyr::pull(cell_barcode)

    A_allele_df<-dplyr::filter(source_df,cell_barcode %in% A_allele_cells)%>%
      dplyr::mutate(A_allele=REFcount,B_allele=ALTcount,Xa="Allele_A")
    B_allele_df<-dplyr::filter(source_df,cell_barcode %in% B_allele_cells)%>%
      dplyr::mutate(B_allele=REFcount,A_allele=ALTcount,Xa="Allele_B")
    expdf<-dplyr::bind_rows(A_allele_df,B_allele_df)%>%
      dplyr::mutate(Used_as_refGene=ifelse(Gene %in% reference_genes,"Yes","No"),
             Used_as_refSNP=ifelse(SNP_ID %in% merged_vars,"Yes","No"))

    expdf_withref<-dplyr::mutate(expdf,Reference_SNP=str_c(merged_vars,collapse=","),
                                 Reference_Gene=stringr::str_c(reference_genes,collapse=","))


    # make per-sample data by summarizing across cells
    per_sample_res<-expdf%>%
      dplyr::mutate(CHR=dplyr::case_when(
        POS<=2781479~"PAR1",
        POS>=155701383~"PAR2",
        TRUE~"nonPAR"
      ))%>%
      dplyr::group_by(Sample_ID,SNP_ID,CHR,POS,REF,ALT,Gene,XCI_status,Gene_class,Used_as_refGene,Used_as_refSNP)%>%
      dplyr::summarize(Total_A_allele=sum(A_allele),Total_B_allele=sum(B_allele),Total_allele=(sum(A_allele)+sum(B_allele)),Expressing_cells=dplyr::n_distinct(cell_barcode))%>%
      ungroup()%>%
      dplyr::mutate(minor_allele_ratio=ifelse(Total_A_allele>Total_B_allele,Total_B_allele/Total_allele,Total_A_allele/Total_allele))%>%
      dplyr::mutate(Reference_Gene=str_c(reference_genes,collapse=","),Num_Reference_Gene=length(unique(reference_genes)),
             Reference_SNP=str_c(merged_vars,collapse=","),Num_Reference_SNP=length(unique(merged_vars)),
             Reference_Cell_Count=(length(A_allele_cells)+length(B_allele_cells)),
             Num_A_cells=length(A_allele_cells),Num_B_cells=length(B_allele_cells),Num_Fail_cells=length(Fail_cells))



    # evaluate whether the inter-SNP phasing increased the number of cells used for analysis
    Max_Num<-dplyr::filter(source_df,SNP_ID%in%merged_vars)%>%
      dplyr::filter((REFcount>0&ALTcount==0&OTHcount==0) | (ALTcount>0&REFcount==0&OTHcount==0))%>%
      dplyr::group_by(SNP_ID)%>%dplyr::summarize(Count=dplyr::n())%>%
      dplyr::arrange(-Count)%>%dplyr::slice(1)%>%dplyr::pull(Count)
    Max_Num_Table<-tibble::tibble(Sample_ID=Sample,Max_single_SNP_cell_Number=Max_Num,Num_valid_cells=length(A_allele_cells)+length(B_allele_cells),
                          Num_A_cells=length(A_allele_cells),Num_B_cells=length(B_allele_cells),Num_Fail_cells=length(Fail_cells),Reference_Gene=str_c(reference_genes,collapse=","),Num_Reference_Gene=length(unique(reference_genes)),
                          Reference_SNP=str_c(merged_vars,collapse=","),Num_Reference_SNP=length(unique(merged_vars)))


    expdf_withref_summary<-dplyr::bind_rows(expdf_withref_summary,expdf_withref)
    Max_Num_Table_summary<-dplyr::bind_rows(Max_Num_Table_summary,Max_Num_Table)
    per_sample_res_summary<-dplyr::bind_rows(per_sample_res_summary,per_sample_res)
  }}

 result_set<-list(expdf_withref_summary=expdf_withref_summary,Max_Num_Table_summary=Max_Num_Table_summary,
                  per_sample_res_summary=per_sample_res_summary,Fail_samples=Fail_samples)

 return(result_set)
 }





#' Run scLinaX analysis for all samples
#' @param ASE_df A dataframe (tibble) containing single-cell allele-specific expression (scASE) data for all samples. This dataframe should have the following columns:
#'   * SNP_ID: SNP identifier
#'   * POS: Genomic position of the SNP (GRCh38)
#'   * REF: Reference allele of the SNP {A,T,G,C}
#'   * ALT: Alternative allele of the SNP {A,T,G,C}
#'   * cell_barcode: Cell barcode
#'   * REFcount: Allelic expression of the reference allele
#'   * ALTcount: Allelic expression of the alternative allele
#'   * OTHcount: Allelic expression of the other allele
#'   * Sample_ID: Sample ID
#'   * Gene: Gene annotated to the SNP
#' @param XCI_ref A dataframe (tibble) containing X chromosome inactivation status. This dataframe should have the following two columns:
#'   * Gene: Gene name
#'   * XCI_status: XCI status {escape, variable, inactive}
#' @param QCREF A dataframe generated for reference gene QC (please see the `run_RefGeneQC` function). QCREF should have the following three columns:
#'   * Gene
#'   * Mean_AR_target
#'   * Mean_AR_reference
#' @param Inactive_Gene_ratio_THR Threshold for the ratio of inactive genes
#' @param SNP_DETECTION_DP Threshold for the total allele count (depth) of the SNP in the scASE data. SNP–Sample pairs with a total allele count of at least "SNP_DETECTION_DP" are used for the analysis. Default: 30.
#' @param SNP_DETECTION_MAF Threshold for the minor allele count of the scASE data. SNP–Sample pairs with a minor allele ratio between "SNP_DETECTION_MAF" and "1 - SNP_DETECTION_MAF" are used for the analysis. Default: 0.1.
#' @param QC_total_allele_THR Threshold for the total allele count (depth) of the SNP used for calculating the ratio of expression from Xi.
#' Note that this count is calculated with cells successfully assigned to the group based on the inactivated X chromosome.
#' This filter is applied in the final step of scLinax and differs from "SNP_DETECTION_DP". Default: 10.
#' @param HE_allele_cell_number_THR Threshold for the number of cells expressing reference SNPs. Candidate reference SNPs expressed in at least "HE_allele_cell_number_THR" cells are used for the analysis. Default: 50.
#' @param REMOVE_ESCAPE Boolean:
#'   * TRUE (default): Remove ASE profiles of SNPs on escapee genes when calculating correlations between pseudobulk ASE profiles.
#'   * FALSE: Include ASE profiles of SNPs on escapee genes when calculating correlations between pseudobulk ASE profiles.
#' @param PVAL_THR Threshold for P-values and absolute correlation coefficients in the correlation analysis of pseudobulk profiles generated for reference SNPs.
#' @param RHO_THR Threshold for absolute correlation coefficients in the correlation analysis of pseudobulk profiles generated for reference SNPs.
#' @return A list of objects ($result, $raw_exp_result, $Fail_list) representing the results of scLinaX.
#' Additional objects representing intermediate results of scLinaX are also included in the list ($clustering_result, $Max_Num_Table_result, $df_snp_summary, $phasing_result).
#' While users may not typically need to use these intermediate objects directly, they are provided for reference.
#'
#' * $result: A per-sample raw result of scLinaX. This data has redundancy and should be summarized using the `summarize_scLinaX` function before analysis.
#'
#'   The dataframe ($result) has the following columns:
#'
#'   - Sample_ID: Sample ID
#'   - SNP_ID: SNP identifier
#'   - CHR: PAR or nonPAR
#'   - POS: Genomic position of the SNP (GRCh38)
#'   - REF: Reference allele of the SNP {A,T,G,C}
#'   - ALT: Alternative allele of the SNP {A,T,G,C}
#'   - Gene: Gene name
#'   - XCI_status: XCI status {escape, variable, inactive, unknown}
#'   - Gene_class: XCI status combined with CHR information {PAR1, nonPAR_escape, nonPAR_variable, nonPAR_inactive, nonPAR_unknown, PAR2}
#'   - Used_as_refGene: Whether the Gene was used as a reference gene {Yes, No}
#'   - Used_as_refSNP: Whether the SNP_ID was used as a reference SNP {Yes, No}
#'   - Total_A_allele, Total_B_allele: Total allele count of allele A and B
#'   - Total_allele: Total allele count of the SNP
#'   - Expressing_cells: Number of cells expressing the SNP
#'   - minor_allele_ratio: Ratio of the expression from the allele (A, B) with lower expression
#'   - Reference_Gene, Reference_SNP: A list of genes used as reference genes and SNPs
#'   - Num_Reference_Gene, Num_Reference_SNP: Number of reference genes and SNPs
#'   - Reference_Cell_Count: Number of cells showing mono-allelic expression of reference SNPs
#'   - Num_A_cells, Num_B_cells: Number of cells showing mono-allelic expression of A and B alleles of reference SNPs
#'   - Num_Fail_cells: Number of cells showing bi-allelic expression of reference SNPs (should be removed from the analysis)
#'
#' * $raw_exp_result: A per-sample raw result of scLinaX.
#'
#'   The dataframe ($raw_exp_result) has the following columns:
#'
#'   - cell_barcode: Cell barcode
#'   - Sample_ID: Sample ID
#'   - SNP_ID: SNP identifier
#'   - CHR: PAR or nonPAR
#'   - POS: Genomic position of the SNP (GRCh38)
#'   - REF: Reference allele of the SNP {A,T,G,C}
#'   - ALT: Alternative allele of the SNP {A,T,G,C}
#'   - REFcount: Allelic expression of the reference allele
#'   - ALTcount: Allelic expression of the alternative allele
#'   - OTHcount: Allelic expression of the other allele
#'   - Gene: Gene name
#'   - XCI_status: XCI status {escape, variable, inactive, unknown}
#'   - Gene_class: XCI status combined with CHR information {PAR1, nonPAR_escape, nonPAR_variable, nonPAR_inactive, nonPAR_unknown, PAR2}
#'   - Used_as_refGene: Whether the Gene was used as a reference gene {Yes, No}
#'   - Used_as_refSNP: Whether the SNP_ID was used as a reference SNP {Yes, No}
#'   - Xa: Information of the activated X chromosome {Allele_A, Allele_B}
#'   - Reference_Gene, Reference_SNP: A list of genes used as reference genes and SNPs
#'
#' * $Fail_list: List of samples for which scLinaX analysis failed.
#'
#' * $clustering_result: Result of the grouping of reference SNPs. Cluster names are in the format {Sample_ID}_cluster_{cluster_ID}.
#'
#' * $Max_Num_Table_result: A dataframe describing the number of cells.
#'
#' * $df_snp_summary: An original dataframe from which Spearman correlation between pseudobulk ASE profiles is calculated.
#'
#' * $phasing_result: Result of the Spearman correlation analysis for pseudobulk ASE profiles.
#'
#'
#' @export



run_scLinaX<-function(ASE_df,XCI_ref,QCREF,Inactive_Gene_ratio_THR=0.05,SNP_DETECTION_DP=30,SNP_DETECTION_MAF=0.1,QC_total_allele_THR=10,
                      HE_allele_cell_number_THR=50,REMOVE_ESCAPE=TRUE,PVAL_THR=0.01,RHO_THR=0.5){

result<-tibble::tibble()
raw_exp_result<-tibble::tibble()
phasing_result<-tibble::tibble()
clustering_result<-tibble::tibble()
Max_Num_Table_result<-tibble::tibble()
df_snp_summary<-tibble::tibble()
Fail_list<-c("Following samples were failed during phasing")

#Run candidate ref gene QC
valid_ref_genes<-Gene_QC(QCREF,Inactive_Gene_ratio_THR)

#QC for ASE df
QCed_df<-make_QCed_df(ASE_df,XCI_ref,SNP_DETECTION_DP,SNP_DETECTION_MAF)

#candidate ref SNP & test sample list
per_SNP_sample<-make_per_SNP_sample_df(QCed_df)
sample_list<-dplyr::filter(per_SNP_sample,Gene%in%valid_ref_genes&Count>=HE_allele_cell_number_THR)%>%
  dplyr::pull(Sample_ID)%>%unique()

#run scLinaX for each sample
NUM_SAMPLE=length(sample_list)
for(i in 1:length(sample_list)){
Sample=sample_list[i]
print(stringr::str_c("Start processing of sample ",i, " (total sample number = ",NUM_SAMPLE,")"))

clustering<-run_clustering(per_SNP_sample,QCed_df,Sample,valid_ref_genes,HE_allele_cell_number_THR,QC_total_allele_THR,REMOVE_ESCAPE,
                           PVAL_THR,RHO_THR)
phasing<-run_grouping(clustering$CLST1,clustering$Merge_list,QCed_df,Sample)


result<-dplyr::bind_rows(result,phasing$per_sample_res_summary)
raw_exp_result<-dplyr::bind_rows(raw_exp_result,phasing$expdf_withref_summary)
phasing_result<-dplyr::bind_rows(phasing_result,clustering$phasing_result)
clustering_result<-dplyr::bind_rows(clustering_result,clustering$clustering_result)
Max_Num_Table_result<-dplyr::bind_rows(Max_Num_Table_result,phasing$Max_Num_Table_summary)
df_snp_summary<-dplyr::bind_rows(df_snp_summary,clustering$df_snp)
Fail_list<-c("Following samples were failed during phasing")

print(stringr::str_c("Finish processing of sample ",i, " (total sample number = ",NUM_SAMPLE,")"))
}

scLinaX_obj<-list(
  result=result,raw_exp_result=raw_exp_result,phasing_result=phasing_result,clustering_result=clustering_result,
  Max_Num_Table_result=Max_Num_Table_result,df_snp_summary=df_snp_summary,Fail_list=Fail_list)

return(scLinaX_obj)
}





#' Summarize scLinaX results (return per-individual summary)
#' @param scLinaX_obj A list object generated by the `run_scLinaX` function.
#' @param QC_total_allele_THR Threshold for the total allele count (depth) of the SNP used for calculating the ratio of expression from Xi. Note that this count is calculated with cells successfully assigned to the group based on the inactivated X chromosome. This filter is applied in the final step of scLinax and differs from "SNP_DETECTION_DP". Default: 10.
#' @param Annotation A dataframe (tibble) for the annotation of the cells. This dataframe should have the following columns:
#'   * cell_barcode
#'   * Annotation
#'
#' @return A dataframe (tibble) containing scLinaX results.
#'
#' If no Annotation is supplied, this function returns the ratio of expression from the inactivated X chromosome for all cells.
#' If Annotation is supplied, this function returns the ratio of expression from the inactivated X chromosome for each cell annotation.
#'
#' The dataframe includes the following columns:
#'
#' - Sample_ID: Sample ID
#' - SNP_ID: SNP identifier
#' - CHR: PAR or nonPAR
#' - POS: Genomic position of the SNP (GRCh38)
#' - REF: Reference allele of the SNP {A,T,G,C}
#' - ALT: Alternative allele of the SNP {A,T,G,C}
#' - Gene: Gene name
#' - XCI_status: XCI status {escape, variable, inactive, unknown}
#' - Gene_class: XCI status combined with CHR information {PAR1, nonPAR_escape, nonPAR_variable, nonPAR_inactive, nonPAR_unknown, PAR2}
#' - Used_as_refGene: Whether the Gene was used as a reference gene {Yes, No}
#' - Used_as_refSNP: Whether the SNP_ID was used as a reference SNP {Yes, No}
#' - Total_A_allele, Total_B_allele: Total allele count of allele A and B
#' - Total_allele: Total allele count of the SNP
#' - Expressing_cells: Number of cells expressing the SNP
#' - minor_allele_ratio: Ratio of the expression from the allele (A, B) with lower expression (=Ratio of the expression from Xi)
#' - Reference_Gene, Reference_SNP: A list of genes used as reference genes and SNPs
#' - Num_Reference_Gene, Num_Reference_SNP: Number of reference genes and SNPs
#' - Reference_Cell_Count: Number of cells showing mono-allelic expression of reference SNPs
#' - Num_A_cells, Num_B_cells: Number of cells showing mono-allelic expression of A and B alleles of reference SNPs
#' - Num_Fail_cells: Number of cells showing bi-allelic expression of reference SNPs (should be removed from the analysis)
#'
#' If in per-cell annotation mode, it includes these additional columns:
#'
#' - Major_allele: The allele with the higher read count {A, B}
#' - Annotation: Cell annotation
#' @export

summarize_scLinaX<-function(scLinaX_obj,QC_total_allele_THR=10,Annotation=NULL){

  summary<-scLinaX_obj$result%>%
    dplyr::select(Reference_SNP,Sample_ID,Reference_Cell_Count)%>%
    dplyr::distinct()%>%dplyr::group_by(Sample_ID)%>%dplyr::arrange(-Reference_Cell_Count)%>%dplyr::slice(1)%>%
    dplyr::ungroup()%>%dplyr::left_join(scLinaX_obj$result,by=c("Sample_ID","Reference_SNP","Reference_Cell_Count"))%>%
    dplyr::filter(Used_as_refGene=="No")%>%
    dplyr::filter(Total_allele>=QC_total_allele_THR)%>%
    dplyr::group_by(Sample_ID,Gene)%>%dplyr::arrange(-Total_allele)%>%dplyr::slice(1)%>%dplyr::ungroup()

  if(is.null(Annotation)){
  return(summary)
  }else{
    data<-scLinaX_obj$raw_exp_result

    df<-dplyr::mutate(summary,Major_allele=ifelse(Total_A_allele>Total_B_allele,"A","B"))%>%
      dplyr::select(Sample_ID,SNP_ID,Reference_SNP,Major_allele)%>%
      dplyr::inner_join(data,by=c("Sample_ID","SNP_ID","Reference_SNP"))%>%
      dplyr::mutate(Major_allele_count=ifelse(Major_allele=="A",A_allele,B_allele),
             Minor_allele_count=ifelse(Major_allele=="B",A_allele,B_allele))%>%
      dplyr::left_join(Annotation,by="cell_barcode")%>%
      dplyr::mutate(Total_allele_count=Major_allele_count+Minor_allele_count)

    per_anno_summary<-df %>%
      dplyr::group_by(Sample_ID,SNP_ID,CHR,POS,Major_allele,Reference_SNP,REF,ALT,Gene,XCI_status,Gene_class,
               Used_as_refGene,Used_as_refSNP,Reference_Gene,Annotation)%>%
      dplyr::summarize(Major_allele_count=sum(Major_allele_count),Minor_allele_count=sum(Minor_allele_count),
                Total_allele=sum(Total_allele_count),Reference_Cell_Count=dplyr::n())%>%
      dplyr::ungroup()%>%
      mutate(minor_allele_ratio=Minor_allele_count/Total_allele)%>%
      dplyr::filter(Total_allele>=QC_total_allele_THR)
    return(per_anno_summary)
  }
}



